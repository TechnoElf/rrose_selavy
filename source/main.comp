#version 450

layout (binding = 0) uniform ParametersUBO {
    uint width;
    uint height;
} param;

layout (binding = 1, rgba32f) uniform image2D img;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

const int MAX_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.0001;
const float ASPECT_RATIO_FACTOR = 3.0/2.0;
const float FIELD_OF_VIEW = 45.0;

float sdf_sphere(vec3 p) {
    return length(p) - 1.0;
}

float sdf_union(float a, float b) {
    return min(a, b);
}

float sdf_intersection(float a, float b) {
    return max(a, b);
}

float sdf_difference(float a, float b) {
    return max(a, -b);
}

float scene(vec3 p) {
    float dist = MAX_DIST;

    dist = sdf_union(dist, sdf_sphere(p - vec3(1.0, 0.0, 0.0)));
    dist = sdf_union(dist, sdf_sphere(p + vec3(1.0, 0.0, 0.0)));
    dist = sdf_difference(dist, sdf_sphere(p));

    return dist;
}

vec3 scene_normal(vec3 p) {
    return normalize(vec3(
        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),
        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),
        scene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

float march(vec3 origin, vec3 dir) {
    float depth = MIN_DIST;

    for (int i = 0; i < MAX_STEPS; i++) {
        float dist = scene(origin + depth * dir);
        if (dist < EPSILON) { return depth; }
        depth += dist;
        if (depth >= MAX_DIST) { return MAX_DIST; }
    }

    return MAX_DIST;
}

void main() {
    vec3 col = vec3(0.0);

    vec3 ray_dir = normalize(vec3((gl_GlobalInvocationID.xy - vec2(param.width, param.height) / 2.0) * vec2(1.0, ASPECT_RATIO_FACTOR), -float(param.height) / tan(radians(FIELD_OF_VIEW)) / 2.0));
    vec3 ray_origin = vec3(0.0, 0.0, 3.0);

    float depth = march(ray_origin, ray_dir);

    if (depth + EPSILON < MAX_DIST) {
        vec3 p = ray_origin + depth * ray_dir;
        vec3 normal = scene_normal(p);

        vec3 to_light = normalize(vec3(1.0, 1.0, 1.0));
        vec3 reflected_light = normalize(2 * dot(to_light, normal) * normal - to_light);

        float shininess = 2;

        vec3 ambient_intensity = vec3(0.3, 0.3, 0.3);
        vec3 diffuse_intensity = vec3(0.5, 0.5, 0.5);
        vec3 specular_intensity = vec3(0.8, 0.8, 0.8);

        vec3 albedo = (normal + 1.0) / 2.0;

        vec3 ambient_reflection = albedo;
        vec3 diffuse_reflection = albedo;
        vec3 specular_reflection = albedo;

        vec3 ambient = ambient_intensity * ambient_reflection;
        vec3 diffuse = diffuse_intensity * dot(to_light, normal) * diffuse_reflection;
        vec3 specular = specular_intensity * pow(dot(reflected_light, normalize(ray_origin - p)), shininess) * specular_reflection;

        vec3 intensity = ambient + diffuse + specular;

        col = clamp(intensity, 0.0, 1.0);
    }

    imageStore(img, ivec2(gl_GlobalInvocationID.x, param.height - gl_GlobalInvocationID.y - 1), vec4(col, 1.0));
}
